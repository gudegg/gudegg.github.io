---
title: 内存分配和回收策略
date: 2017-11-28 19:59:21
tags: java虚拟机
---

> 对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配），**对象主要分配在新生代的Eden区**上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。

#### 对象优先在Eden区分配
大多数情况下。对象在新生代的Eden区分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次MinorGC
#### 大对象直接进入老年代
大对象指需要连续大量空间的java对象，如很长的字符串以及数组(byte[10\*1024\*1024]),虚拟机提供-XX:PretenureSizeThreshold参数，另大于这个设置值的对象直接在老年代分配，避免在Eden区及两个Survivor区之间发生大量的内存复制(新生代:**复制算法**)。PretenureSizeThreshold只对Serial和ParNew收集器有效，对Parallel Scavenge收集器无效，它一般不需要这个设置。
![](/images/内存分配老对象.png)
<!--more-->
#### 长期存活对象进入老年代
 虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应当放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold来设置。
 #### 动态对象年龄判定
为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，**如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄**。
#### 空间分配担保
在发生Minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。
1. 如果大于，可以确保Minor GC安全
2. 如果小于，虚拟机会查看HandlePromotionFailure设置值是否允许担任失败.
    1. 如果允许，那么会继续检查老年代最大连续可用空间是否大于历次晋升老年代对象的平均大小
        1. 如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的
        2. 如果小于，进行一次Full GC.
    2. 如果不允许，也要改为进行一次Full GC. 

取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（HandlePromotionFailure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁.

> Jdk6 Update24之后,HandlePromotionFailure参数不在影响到虚拟机的空间分配担保策略，规则变为：只要老年代连续的空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC.

. 